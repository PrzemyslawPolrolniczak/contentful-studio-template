# lulu-fe

`lulu-fe` is a npm package for shared code in Lulu frontend projects. Initially there was only one theme and design language. In the dawn of the new [dashboard](https://gitlab.com/lulu-press/upp/frontends/lulu-dashboard) project a new theme was added. Therefore you'll find 2 separate themes: **Amber** and **Classic**. Over time both themes might be merged into one single one but as of now (Autumn 2024) they are separate and should be treated as such.

```
lulu-fe/
├─ src/ <-- everything except amber folder is the "classic" theme
│  ├─ amber/ <-- everything amber related (components, styles etc)
│  │  ├─ components/
│  │  ├─ styles/
│  │  ├─ .../
│  ├─ styles/
│  ├─ ui-components/
│  ├─ .../
├─ .../ <-- shared infrastructure
```

Like in a small monorepo, both themes share infrastructure (like linters, prettier, vite configuration, etc.) and can also share non-visual code. Example: An Amber component can use a Classic hook or util and vice versa.

> Amber and Classic should not include each others components as they aren't really compatible (for now). Both also rely on a few global styles which would bleed into each other. Always check your imports and directly import what you need. **Do not use barrel imports between components!**

Both themes have a dedicated storybook. We also offer a combined Storybook (composition) to show both within the same UI.

A published Storybook instance of the latest version (last commit on `main`) can be seen here: 

- https://lulu-press.gitlab.io/upp/frontends/lulu-fe/ (both)
- https://lulu-press.gitlab.io/upp/frontends/lulu-fe/amber/ (amber)
- https://lulu-press.gitlab.io/upp/frontends/lulu-fe/classic/ (classic)

## Figma

Figma reference templates can be found here:

**Classic:** https://www.figma.com/design/lI25SgJH8s1h9wQUOWOL70/Lulu-UI-Library?m=auto&t=37edWFc5AMz5Je0m-6

**Amber:** https://www.figma.com/design/LKBvX6UYEw5JegKVCBrbbV/Dashboard-Component-Library?m=auto&t=37edWFc5AMz5Je0m-6

[![Commitizen friendly](https://img.shields.io/badge/commitizen-friendly-brightgreen.svg)](http://commitizen.github.io/cz-cli/)

## Installation:

### Prerequisites:

Node: active LTS Version of Node (see `.nvmrc` file for specific version number) and the respective packaged npm version.

To be able to install the package via `npm install` you have to configure your local `npm` to use an appropriate auth token for accessing the private `lulu-fe` npm registry.

`WkbdguY5HGGQF82HRcwN` is the value of a Deploy Token in this repo with a scope of `read_package_registry`. It was generated by the [gitlab-config repo](https://gitlab.com/lulu-press/upp/infra/gitlab-config/).

To use the token locally, run this command:

```bash
npm config set -- '//gitlab.com/api/v4/packages/npm/:_authToken' "WkbdguY5HGGQF82HRcwN"
```

Next, create a `.npmrc` file in the consuming project's root directory with the following content:

```bash
@lulu-press:registry=https://gitlab.com/api/v4/packages/npm/
```

Finally you should be able to install `lulu-fe` in your project running:

```bash
npm install @lulu-press/lulu-fe
```

After a successful installation you can import and use the available components:

In your App/index file you have to import the stylesheet first:

```javascript
import "@lulu-press/lulu-fe/dist/styles.css";
```

Then you can import the named exports of the lulu-fe components you need:

```javascript
import { Button, Icon, Icons } from "@lulu-press/lulu-fe";
```

## Commands

### Build

```bash
npm run build
```

This creates the publishable package artifacts with Rollup and puts them in the `dist` folder.

### Development

```bash
npm build:watch
```

This builds to `/dist` and runs the project in watch mode so any edits you save inside `src` causes a rebuild to `/dist`.

### Storybook

As both design systems ("Classic" and "Amber") can't run together we, offer 2 separated storybooks.

To run the "Classic" version use:
```bash
npm run storybook:classic
```
To run the "Amber" version use:
```bash
npm run storybook:amber
```

To run both storybooks within a parent storybook using [composition](https://storybook.js.org/docs/sharing/storybook-composition) use:
```bash
npm run storybook
```

### Creating new UI component

```bash
npm run new
```

This command uses plopjs underneath (https://github.com/plopjs/plop) to create all the necessary boilerplate for a new component. It automatically creates `module.scss`, `test.tsx` and `stories.tsx` files. While almost every component should have a story, sometimes a stylesheet or test file won't be needed and can be removed. This is by design, as tests should be treated as a default and only skipped if they don't bring any value.

### Running tests

```bash
npm test
```

This project uses React Testing Library with Jest. For more information, see: https://github.com/testing-library/react-testing-library Make sure to understand the underlying [philosophy](https://testing-library.com/docs/react-testing-library/intro#this-solution) and [avoid](https://testing-library.com/docs/#what-you-should-avoid-with-testing-library) testing implementation details. [Avoid the test user](https://kentcdodds.com/blog/avoid-the-test-user/).

During development, it is convenient to run the interactive Jest mode:

```bash
npm run test:watch
```

## Package development & Contribution

> Always make sure the `dist` build is correctly consumable as expected. As this library will be a dependency of possibly many other projects, every breaking change should be considered carefully.

### Local usage with consuming projects (linking)

To develop the package in the context of local app that consumes `lulu-fe`, you'll need to link it first. There are a couple options for doing so.

**Important:** As most of our other FEs use Vite for bundling, you need to be aware of https://vitejs.dev/guide/dep-pre-bundling.html#caching - so when using `yalc link` resp. `npm link` the `package.json` of the consuming file won't be touched. Hence the bundler won't invalidate the dependency cache!

> In the _CONSUMING_ project: If for some reason you want to force Vite to re-bundle deps, you can either start the dev server with the `--force` command line option, or manually delete the `node_modules/.vite` cache directory.

#### [yalc](https://github.com/wclr/yalc)

yalc's `link` function creates a symlink between your local package and a consuming app and temporarily replaces the `lulu-fe` instance in the consuming app's `node_modules` directory.

Initial link (performed once):

```bash
# in lulu-fe
npm run build
yalc publish

# in consuming project
yalc link @lulu-press/lulu-fe

# alternatively, if `lulu-fe` dependencies have been updated in the published yalc instance
# docs: https://github.com/wclr/yalc#add
yalc add @lulu-press/lulu-fe
npm install
# be sure not to commit changes resulting from these commands
```

After any lulu-fe code change:

```bash
# in lulu-fe
npm run build
yalc push
```

Once you're done developing, to remove the symlink in order to use your consuming project's source-controlled version of `lulu-fe` again:

```bash
# in your consuming project
yalc remove @lulu-press/lulu-fe
npm install
```

#### [npm link](https://docs.npmjs.com/cli/v8/commands/npm-link)

NPM link handles your local `lulu-fe` package like a standard NPM module.

```bash
cd lulu-fe
npm link
cd <your project path>
npm link @lulu-press/lulu-fe
```

NPM link comes with the benefit of live reloads using Rollup's watch mode; any code change you make in `lulu-fe` will automatically render in your local consuming app.

```bash
# 1. in lulu-fe
npm run build:watch

# 2. in your consuming project
npm run start:local
```

Once you're done developing, in order to use your consuming project's source-controlled version of `lulu-fe` again:

```bash
# 1. in your consuming project
npm unlink --no-save @lulu-press/lulu-fe
npm install

# 2. in lulu-fe
npm unlink
```

### Styling

We are using SCSS modules to style components. Styles should be scoped per component and live inside the root component directory called `<Component>.module.scss`

There are also global styles (typography, grid, utility classes etc.) which are included into `src/styles/index.scss`. All styles are bundled into a `dist/styles.css`file which is meant to be imported in your consuming project. Also part of the distributed files is the `dist/styles/variables.scss` file which should be used in the consumer project styles as it contains all lulu specific style guide variables.

As Sass `@import` became [deprecated](https://sass-lang.com/documentation/at-rules/import) we use `@use` which is [the new best practice](https://sass-lang.com/documentation/at-rules/use) to import styles within styles.

If you're coming from BEM like styles be aware of [css-modules powerful](https://github.com/css-modules/css-modules#composition) `composes` keyword as it creates modifiers automatically for you.

> TL;DR: In order to use the styles (and icons) you have to import the `dist/styles.css` into the consuming project
> like:
> `import '@lulu-press/lulu-fe/dist/styles.css';`

### Icons

#### Classic
We are using [fantasticon](https://github.com/tancredi/fantasticon) (the successor of the deprecated `icon-font-generator` library) for
generating our iconfont (and associated meta information such as TS types).

To add a new icon simply drop the correctly named `.svg` file into the `src/styles/assets/icons` folder.

Then run `npm run icons:generate` to (re-)generate the iconfont, css and other needed files. They all end up in
`src/styles/assets/iconfont` if you need a closer look. If you need to tweak the config of the generator see the
`fantasticonrc.js` file in the root. The related overview story should update automatically as it is built upon the generated types.

#### Amber
We are using [svgr](https://react-svgr.com/) to convert raw svg files into React components which are bundled within lulu-fe.

To add a new icon simply drop the correctly named `.svg` file into the `src/amber/icons/raw` folder.

Then run `npm run icons:generate:amber` to (re-)generate the icon components, and other needed files (`src/amber/icon-types.ts`). They all end up in
`src/amber/icons` if you need a closer look. If you need to tweak the config of the generator see the
`src/amber/svgr.config.cjs` file. The related overview story should update automatically as it is built upon the generated types.

### TypeScript

This project uses a strict config to take full advantage of TypeScript.

### i18n

Components which need text labels will eventually need translations as well. In order to make that work, you need to understand how label strings are provided to the components. As we wanted to avoid adding lingui-js or other heavy i18n solutions as a direct dependency to lulu-fe we decided to choose another path:

- All dynamic labels should be stored in the `src/extensions/CopyContext.tsx` file and retrieved within the component using the `useCopy()` function from the `CopyContext`. See existing code as example.

- In your consuming app you usually will create your own `CopyContext` which contains translatable strings (e.g. using lingui `<Trans>` macros) and will be used by the lulu-fe components when running within the host.

- sooner or later you will extract the translation files (in .po format) in your app which then will contain a lot of empty message strings like

  ```
  #: src/contexts/CopyContext.tsx:13
  msgid "Back to"
  msgstr ""
  ```

  To make it easier to translate those reused component strings, lulu-fe provides pre-translated po files under `/i18n/`.

- In order to merge those translations with your generated translation within your app you can use po-merge tools. A simple tool is `msgcat`. See description here: https://phrase.com/blog/posts/combine-po-translation-files/

- `msgcat` is part of the `gettext` toolbox which you can install via:

  ```bash
  $ brew install gettext
  ```

- once installed you could run:

  ```bash
  $ msgcat messages.po messages-lulu-fe.po -o messages-merge.po
  ```

  assuming all files are within the same folder. They will be merged from left to right and the result will end up in the file specified after the `-o` argument. By default only empty strings will be overwritten.

### Dependencies

Make sure to add potential dependencies correctly.

- `dependencies` are runtime dependencies which can't be expected from the consumer.
- `peerDependencies` are expected to be provided by the consuming project. npm v7 installs them automatically - if you use an older version you might have to install them manually (within the expected version range)
- `devDependencies` are packages which are only relevant during the development process (linters, test runners,
  storybook etc.)

## Publishing

### Publishing to NPM

We use a private npm registry which is part of gitlab. See [docs here](https://docs.gitlab.com/ee/user/packages/npm_registry/). We also use https://github.com/semantic-release/semantic-release which handles the versioning and publishing part mostly automatically.

First: Understand [how it works!](https://github.com/semantic-release/semantic-release#how-does-it-work)

The [semantic version](https://semver.org/) (MAJOR.MINOR.PATCH) is calculated from the commit messages which are merged into master. Respect these "trigger words" and use them correctly.

Strive for [atomic commits](https://en.wikipedia.org/wiki/Atomic_commit). A commit should contain exactly one self-contained functional change and a functional change should be contained in exactly one commit. If you have multiple commits in your feature-branch, squash them but set the commit message of the resulting commit correctly in order to let the commit parser pick up your changes. (see [here](https://github.com/semantic-release/semantic-release/blob/master/docs/support/troubleshooting.md#squashed-commits-are-ignored-by-semantic-release))

### Example:

| What?                          | commit message                                 | result                                      |
| ------------------------------ | ---------------------------------------------- | ------------------------------------------- |
| adding a new component "Label" | feat(Label): add Label component [LU-XX]       | Minor version gets bumped (1.0.0 -> 1.1.0)  |
| fixing a bug                   | fix(Pagination): calculate correct page number | Patch version gets bumped (1.1.0 -> 1.1.1)  |
| making breaking changes        | feat(Button): BREAKING CHANGE: modified props  | Major version gets bumped (1.1.1 -> 2.0.0)  |
| fixing a typo in docs          | chore(docs): fix typo                          | no version change, no release (still 1.1.1) |

Any commit message that starts with something other than `feat(XXX):`, `fix(XXX):` or `perf(XXX):` **will not trigger a release**. Be careful when squashing Merge Request commits; by default the resulting commit is the name of the Merge Request, and if that does not follow the convention, a release will not be created.

We are using the default which is based on `angular` conventions: https://github.com/angular/angular/blob/master/CONTRIBUTING.md#commit-message-header

For commit messages we are using https://github.com/commitizen/cz-cli. Commit your work with standard git commands and an interactive dialog will help you with the correct commit message in order to work with semantic-release. Be aware: some git GUIs ignore interactive commits so it is recommended to use a terminal for these commits.

You can use

```bash
npx cz
```

or, if you have `commitizien` installed globally:

```bash
git cz
```

### Module Formats

CJS, ESModules, and UMD module formats are supported.

The appropriate paths are configured in `package.json` and `dist/index.js` accordingly.

..
